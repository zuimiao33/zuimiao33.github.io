[{"id":"a6e405427fd8d051ccfd3a263b2eb229","title":"python基础语法","content":"Python3入门\nAuthor:XXXWANG\nDate:2022&#x2F;6&#x2F;1\n参考资料：Python Crash Course by Eric Matthes\n\n[TOC]\n\n##一、变量和简单数据类型\n###1.1 变量\n\n内存比作一个仓库  \n变量，用于在内存中存放数据的容器\n变量名比作货物标号，变量值比作货物获取变量地址id(variable)\n\n####1.1.1 变量定义规则1、全局变量尽量在文件开头2、变量只能是数字、字符串、“_”的组合3、变量的第一个字符不能是数字4、关键字不能作为变量名\n变量名定义规范  \n1、驼峰体\nAgeOfOldboy = 45  \nNumberOfStudents = 11  \n\n2、下划线（官方推荐）\nage_of_oldboy = 45  \nnumber_of_students = 11\n定义变量不好的方式 \n1、用拼音、中文作为变量2、变量名过长3、变量名不要没有意义4、首字母大写（大写用于定义类名）\n####1.1.2  变量的修改与删除\n\n变量值修改，对应地址也会变(如仓库中将货号贴到其余位置，原位置物品将自动被删除)\n删除变量del variable\n\n1.2 字符串一系列字符，用引号括起来的都是字符串，可以单引号，也可以是双引号。多引号用于多行字符串。\n1.2.1 使用方法修改字符串的大小写\n首字母大写name.titile()\n全部大写  name.upper()\n全部小写  name.lower()\n\n1.2.2 合并字符串使用”+”来合并字符串\n1.2.3 制表符或换行符添加空白\\t\t#制表符\n\\n  #换行符\n\n1.2.4 删除空白空白很重要，在一些网站检查用户名时，额外的空格会导致错误。使用\nstr.strip()\n即可去除末端多余空白。（删除是暂时的，若想永久保存需重新赋值。)\nstr.lstrip去除左边空白\nstr.rstrip去除右边空白\n1.2.5 字符串的格式化输出如果单纯使用字符串的+是字符串拼接会使代码繁琐，下面将用format方法使字符串格式化输出。\nformat方法老版\npizzas = ['pineapple', 'chess', 'Orleans']\nfor pizza in pizzas:\n    print(\"There is a &#123;&#125; pizza\".format(pizza))\n\nformat方法新版\npizzas = ['pineapple', 'chess', 'Orleans']\nfor pizza in pizzas:\n    print(f\"There is a &#123;pizza&#125; pizza\")\n\n第二种方法明显更加简便快捷。\n1.3 数字1.3.1 整数print(2 + 3)\nprint(3 - 2)\nprint(2 * 3)\nprint(3 / 2)\nprint(3 ** 2)  # 乘方\nprint(2 + 3 * 4)\nprint((2 + 3) * 4)\n\n\n1.3.2 浮点数结果的小数位数不确定\n0.1 + 0.1\n0.2\n0.2 + 0.1\n0.30000000000000004\n3 * 0.1\n0.30000000000000004\n0.1 + 0.1\n0.2\n\n\n1.3.3 使用str()函数避免类型错误使用str()函数将数字类型转变为字符串类型\nage = 23\nmessage = \"Happy \" + str(age) +\"rd Birthday!\"\nprint(message)\n\n\n\n1.4 注释注释可以对代码添加说明，解决复杂问题提供思路。\n1.4.1 如何编写注释# 向大家问好\nprint(\"Hello Python people.\")\n\n1.4.2 该编写怎样的注释在程序中编写描述性注释，简洁、清晰。\n1.4.3 Python之禅import this\nBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren’t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one– and preferably only one –obvious way to do it.Although that way may not be obvious at first unless you’re Dutch.Now is better than never.Although never is often better than right now.If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea – let’s do more of those!Hello Python people.\n二、 列表介绍2.1 列表是什么列表：按特定顺序排列的元素组成。（字母，数字，列表…任何类型的元素)通常同复数命名列表。[ ]来表示列表。\n创建列表\nname = []\nname = set()\n\n2.1.1 访问列表元素索引从0开始,如:name[0] 则去除列表第一个数\n索引为-1时取最后一个\n2.2 修改、添加、和删除元素2.2.1 修改列表元素motorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles)\nmotorcycles[0] = 'ducati'\nprint(motorcycles)\n\n2.2.2 列表中添加元素1.在列表末尾添加元素\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.append('ducati')\n\n2.在列表中插入元素\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nmotorcycles.insert(0,'ducati')\n\n在指定索引处插入元素。\n2.2.3 从列表中删除元素1.del是python全局函数，哪里都可以使用。(使用索引删除)\nmotorcycles = ['honda', 'yamaha', 'suzuki']\ndel motorcycles[0]\n\n2.使用pop（）删除\npop()可删除列表末尾的元素，并返回弹出值。列表就像栈，删除列表末尾相当于弹出栈顶元素。也可使用索引删除\nmotorcycles = ['honda', 'yamaha', 'suzuki']\npopped_motorcycles = motorcycles.pop()\n\n\n如果删除的值没用就用del,若要重复利用则用pop。\n\n3.根据值删除\nremove()\n motorcycles = ['honda', 'yamaha', 'suzuki']\n motorcycles.remove('honda')\n\nremove()只删除第一个指定的值（含多个重复值时）\n2.3 组织列表对列表元素进行排序,默认按照小写字母进行排序。有大写字母时排序复杂\n2.3.1 使用sort()对列表进行永久性排序sort()方法能轻松将字母顺序进行排序\ncars = ['bmw', 'audi', 'toyota', 'subaru']\ncars.sort()\nprint(cars)\n\n若要按字母相反的顺序排序\ncars = ['bmw', 'audi', 'toyota', 'subaru']\ncars.sort(reverse=True)\nprint(cars)\n\n这两种方法都是永久性更改，原来列表顺序不可恢复\n2.3.2 使用函数sorted()对列表进行临时排序sorted()函数能让列表按照指定顺序排列，同时也不会影响列表原始排列顺序。\ncars = ['bmw', 'audi', 'toyota', 'subaru']\nprint(\"Here is the original list:\\n\", cars)\nprint(\"Here is the sorted list:\\n\", sorted(cars))\nprint(\"Here is the original list again:\\n\", cars)\n\n2.3.3 倒着打印列表cars.reverse()\n无返回值,需重新打印\n并非按照字母顺序相反排序，而是直接反转列表所有元素。\n2.3.4 确定列表的长度使用函数len()快速获取长度\nlen(cars)\n三、操作列表3.1遍历列表for循环是python中的一种循环功能，能够是重复工作简单化。如取出列表中的每一个元素.\nnames = ['alice','eric','steve']\nfor name in names:\n\tprint(name)\n\nname是此次循环中的临时变量,每经历一次循环分别取出对应值赋值给name,如第一次循环将names中的alice赋值给name。临时变量可指定任意名称,通常用单复数区别变量名和列表名.\n\n注：for循环内的语句都需缩进\n\nfor循环执行结束后才会执行后面的语句\n\n\n3.2 避免缩进错误不必要的缩进\n  message = \"Hello Python world!\" \n\tprint(message)\n\n不要遗漏for后面的冒号\n for magician in magicians\n\tprint(magician)\n\n magicians后面的冒号：告诉python下一行是循环第一行若没有则会报错：\n3.3 创建数值列表3.3.1 使用函数range()如何轻松打印一系列数字\nfor i in range (1,5):\nprint(i)\n\n打印的结果是(左闭右开)\n1\n2\n3\n4\n\n3.3.2 使用range()创建数值列表numbers = list(range(1,6))\nprint(numbers)\n\n如此创建了一个列表[1,2,3,4,5]\n建立一个1~9的平方的列表\nsquares = []\nfor value in range(1, 10):\n    squares.append(value ** 2)\nprint(squares)\n\n\n\nrange函数包含步长功能\neven_numbers = list(range(1,6,2))\t#步长为2\nprint(even_numbers)\n\n这样就从1开始每次加2取为列表元素得到列表[1,3,5]\n3.3.3 对数字列表进行统计运算digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\nmin(digits)\t#最小值\n0\nmax(digits)\t#最大值\n9\nsum(digits)\t#求和\n45\n\n\n\n3.3.4 列表解析上述生成squares列表用了三四行代码，而列表解析能使用一行代码进行解决。\nsquares &#x3D; [value**2 for value in range(1,10)]\nprint(squares)\n\n注：这里的for后面没有冒号\n3.4 使用列表的一部分处理列表的部分元素——切片\n3.4.1 切片切片需要指定第一个元素和最后一个元素的索引\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(players[0:3]) \n\n若没有指定第一个值则从开头开始[:3],如果切到末尾则省去第二个值[1:]。\n3.4.2 遍历切片players = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(\"Here are the first three players on my team:\")\nfor player in players[:3]:\n\tprint(player.title())\n\n3.4.3 复制列表原理：切片获得整个列表然后赋值\nmy_foods = ['pizza', 'falafel', 'carrot cake'] \nfriend_foods = my_foods[:]\t# friend_foods = my_foods不行\nprint(\"My favorite foods are:\") \nprint(my_foods)\nprint(\"\\nMy friend's favorite foods are:\")\nprint(friend_foods) \n\nfriend_foods &#x3D; my_foods不行，这是因为将变量friend_foods指向变量my_foods，将同步变化.\n3.5 元组列表非常适合储存一些可变的数据集，而有时需要创建一下不可以修改的元素，元组可以满足这种需求。不可变的列表叫做元组。\n3.5.1 定义元组元组非常像列表,但是使用()圈起来。\ndimensions = (200, 50) \nprint(dimensions[0])\nprint(dimensions[1])\n\n3.5.2 修改元组变量虽然不能修改元组的元素，但可以给存储元组的变量赋值。\ndimensions = (200, 50) \nprint(\"Original dimensions:\")\nfor dimension in dimensions:\n \tprint(dimension) \ndimensions = (400, 100) \nprint(\"\\nModified dimensions:\")\nfor dimension in dimensions:\n    print(dimension)\n\n\n\n3.6 设置代码格式3.6.1 格式设置指南\nPEP 8是最古老的PEP之一，它向Python程序员提供了代码格式设置指南。\n\n3.6.2 缩进PEP 8建议每级缩进都使用四个空格，这既可提高可读性，又留下了足够的多级缩进空间。（一个tab)\n3.6.3 行长最好不要超过编译器上面的垂直参考线。\n3.6.4 空行要将程序的不同部分分开，可使用空行。如果你有5行创建列表的代码，还有3行处理该列表的代码，那么用一个空行将这两部分隔开是合适的。然而，你不应使用三四个空行将它们隔开。\n四、if语句条件测试，以用来选择需要的条件。\n4.1 条件测试每条if语句的核心都是一个值为True或False的表达式，这叫做条件测试。如果测试的值为True则执行if后面的代码，如果为False则忽略。\ncar = 'audi'\ncar == 'bwm'\nFalse\n\n检测时需要注意大小写，大小写也会影响判断。\n4.1.1 检查是否不相等判断两个值是否不等，可结合使用惊叹号和等号（! &#x3D;），其中的惊叹号表示不。\ncar = 'bmw'\nif car != 'audi':\n    print(\"I don't like it!\")\n\n4.1.2 比较数字age = 18\nage == 18\n>>True\n\n4.1.2 检查多个条件\n使用and检查多个条件，如果多个条件均成立则返回True否则返回False.\n使用or检查多个条件，有一个条件成立就返回True，都不成立返回False.\n\n4.1.3 检查特定值是否在列表中要判断特定的值是否已包含在列表中，可使用关键字in。\nrequested_toppings = ['mushrooms', 'onions', 'pineapple'] \n'mushrooms' in requested_toppings \n>>>True\n'pepperoni' in requested_toppings\n>>>False\n\n4.1.4 检查特定值是否不包含在列表中例如一个论坛中一个用户被禁言，在用户评论时检查他是否处于禁言名单中。\nbanned_users = ['andrew', 'carolina', 'david'] user = 'marie' \nif user not in banned_users:\n\tprint(user.title() + \", you can post a response if you wish.\")\n\n4.1.5 布尔表达式条件测试的别名，通常用于记录条件。如游戏是否正在运行，用户是否可以编辑网站特定的内容。\ngame_active = True\ncan_edit = False \n\n4.2 if语句4.2.1 if else 语句if-else语句块类似于简单的if语句，但其中的else语句让你能够指定条件测试未通过时要执行的操作。\nage = 17\nif age >= 18:\n\tprint(\"You are old enough to vote!\")\n\tprint(\"Have you registered to vote yet?\")\nelse:\n\tprint(\"Sorry, you are too young to vote.\")\n    print(\"Please register to vote as soon as you turn 18!\")\n\n4.2.2 if elif else 语句经常需要检查超过两个的情形，为此可使用Python提供的if-elif-else结构。\n例：根据年龄收费的游乐园\n\n4岁以下免费\n4~18岁收费5美元\n18岁（含）以上收费10美元。\n\nage = 12\nif age &lt; 4:\n    print(\"Your admission cost is $0.\")\nelif age &lt; 18:\n    print(\"Your admission cost is $5.\")\nelse:\n    print(\"Your admission cost is $10.\")\n\n\n\n五、字典字典储存的值为key-value形式，创建字典name&#x3D;{ }\n\n字典查询可以直接取出，用于字典量很大时查询某一个值，而不用遍历列表速度太慢。\n\n如：\nalien_0 = &#123;'color': 'green', 'points': 5&#125;\nprint(alien_0['color'])\nprint(alien_0['points'])\n\n\n5.1 使用字典5.1.1 访问字典中的值alien_0 = &#123;&#39;color&#39;: &#39;green&#39;&#125;一个字典\ncolor 为key,green为value。key就好比钥匙，value就是锁\nprint(alien_0[&#39;color&#39;])这样就能取出key对应的值\n5.1.2 添加键值对做一个游戏，设置外星人的坐标。\nalien_0 = &#123;'color': 'green', 'points': 5&#125;\nprint(alien_0) \nalien_0['x_position'] = 0\nalien_0['y_position'] = 25\nprint(alien_0) \n\n5.1.3 修改字典中的值alien_0 = &#123;'color': 'green'&#125;\nprint(\"The alien is \" + alien_0['color'] + \".\")\nalien_0['color'] = 'yellow' \nprint(\"The alien is now \" + alien_0['color'] + \".\") \n\n中途修改外星人的颜色。\n5.1.4 删除键值对\n删除的键值对永远消失。\n\nalien_0 = &#123;'color': 'green', 'points': 5&#125; \ndel alien_0['points']\n\n5.2 遍历字典5.2.1 遍历字典中的所有键值对不像遍历列表只用一个变量，遍历字典需要用两个变量。一个赋值key，一个赋值value。\n如：\nfor k, v in user_0.items() \n\nitems方法是字典中返回键值对的方法。\n5.2.2 遍历字典中的所有键for name in favorite_languages.keys(): \nkeys方法用于返回字典中的key.\n5.2.3 按顺序遍历字典中的所有键for name in sorted(favorite_languages.keys()): \n5.2.4 遍历列表中所有值 for language in favorite_languages.values():\n当数据很大时，如何剔除其中的重复值。要用到集合的方法。set()创建一个集合数据类型(无序，互异，确定）,集合是也是{}，空集合必须用set()\nfor language in set(favorite_languages.values()): \n5.3 嵌套有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。\n5.3.1 字典列表alien_0 = &#123;'color': 'green', 'points': 5&#125;\nalien_1 = &#123;'color': 'yellow', 'points': 10&#125;\nalien_2 = &#123;'color': 'red', 'points': 15&#125;\naliens = [alien_0, alien_1, alien_2]\nfor alien in aliens:\n    print(alien)\n\n上述将三个不同外星人的数据存储在一个列表中。\n5.3.2 在字典中储存列表如储存披萨信息:\npizza = &#123;\n\t'crust': 'thick',\n\t'toppings': ['mushrooms', 'extra cheese'],\n    &#125;\n\n5.3.3 在字典中储存字典如一个论坛中，存储一个用户的信息:\nusers = &#123;\n    'aeinstein': &#123;\n        'first': 'albert',\n        'last': 'einstein',\n        'location': 'princeton',\n    &#125;,\n    'mcurie': &#123;\n        'first': 'marie',\n        'last': 'curie',\n        'location': 'paris',\n    &#125;,\n\n&#125;\n\n\n\n六、用户输入和while循环通过获取用户输入并学会控制程序的运行时间，可编写出交互式程序。\n6.1 函数input()函数input()能让程序暂停运行，等待用户输入一些文本。获取输入之后，将储存在一个变量中，方便使用.\n例：获取用户的姓名\nname = input(\"请输入你的姓名：\")\nprint(\"你的姓名是：\",name)\n\n有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示存储在一个变量中，再将该变量传递给函数input()。这样，即便提示超过一行，input()语句也非常清晰。\nprompt = \"If you tell us who you are, we can personalize the messages you see.\"\nprompt += \"\\nWhat is your first name? \"\nname = input(prompt)\nprint(\"\\nHello, \" + name + \"!\")\n\n6.1.1 使用int()获取输入的数字使用input()输入数字时，python会将其认为是字符串，应手动将其类型改为数字类型。\n>>> age = input(\"How old are you? \")\nHow old are you?21 \n>>> age = int(age)\n>>> age >= 18\nTrue \n\n6.1.2 求模运算符%求模运算符能指出两数相除的余数，可用于判断奇数、偶数。\nnumber = input(\"Enter a number, and I'll tell you if it's even or odd: \")\nnumber = int(number)\nif number % 2 == 0:\n    print(\"\\nThe number \" + str(number) + \" is even.\")\nelse:\n    print(\"\\nThe number \" + str(number) + \" is odd.\"\n\n6.2 while循环for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条件不满足为止。\ncurrent_number = 1\nwhile current_number &lt;= 5:\n    print(current_number)\n    current_number += 1\n\n上述代码为简单计数器，直到计数到5才停止运行。\n6.2.1 让用户选择何时退出prompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nmessage = \"\"\nwhile message != 'quit':\n    message = input(prompt)\n    if message != 'quit':\n        print(message)\n\n当用户输入quit时退出while循环。\n6.2.2 使用标志我们让程序在满足指定条件时就执行特定的任务。但在更复杂的程序中，很多不同的事件都会导致程序停止运行；在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为标志，充当了程序的交通信号灯。\n在上一个代码中我们加入一个标志名为active\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\nactive = True\nwhile active:\n    message = input(prompt)\n    if message == 'quit':\n    \tactive = Falese\n    else:\n        print(message)\n\n6.2.3 使用break退出循环要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句。\nprompt = \"\\nPlease enter the name of a city you have visited:\"\nprompt += \"\\n(Enter 'quit' when you are finished.) \"\nwhile True:\n    city = input(prompt)\n    if city == 'quit':\n        break\n    else:\n        print(f'I d like to &#123;city&#125;')\n\n6.2.4 在循环中使用continue要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环。\ncurrent_number = 0\nwhile current_number &lt; 10:\n    current_number += 1\n    if current_number % 2 == 0:\n        continue\n    print(current_number)\n\n只打印1-10中的奇数，如果是偶数取余为0满足if条件执行continue返回循环不执行下面的语句。\n七、函数函数是带名字的代码块，用于完成具体的工作。\n7.1 定义函数def greet_user():\n    \"\"\"显示简单的问候语\"\"\"\n    print(\"hello\")\n\n\ngreet_user()\n\n 上述为一个简单的函数,def 来定义一个函数,后跟函数名（）,函数内容为执行print语句。\n7.1.1 向函数传递信息只需稍作修改，就可以让函数greet_user()不仅向用户显示Hello!，还将用户的名字用作抬头。\ndef greet_user(username):\n    \"\"\"显示简单的问候语\"\"\"\n    print(\"hello\")\n    print(\"Hello, \" + username.title() + \"!\")\n\n\ngreet_user('alex')\n\n7.1.2 实参和形参上述greet_user()内username就是形参,而’alex’是实参。函数将实参’Alex’传递给了函数greet_user()，这个值被存储在形参username中。\n7.2 传递实参鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参都由变量名和值组成；还可使用列表和字典。下面来依次介绍这些方式。\n7.2.1 位置实参最简单的关联实参和形参方式是基于实参的顺序。这种关联方式被称为位置实参。\ndef describe_animal(animal_type, animal_name):\n    \"\"\"显示宠物的信息\"\"\"\n    print(f\"I have a &#123;animal_type&#125;.\")\n    print(f\"My &#123;animal_type&#125;'s name is &#123;animal_name&#125;\")\n\n\ndescribe_animal('dog', 'xiaobai')\n\n上述代码将实参dog传给了形参animal_type,实参xiaobai传递给了形参animal_name.\n\n位置传参的顺序十分重要，不能颠倒顺序，需要一一对应。\n\n7.2.2 关键字实参关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。\ndef describe_animal(animal_type, animal_name):\n    \"\"\"显示宠物的信息\"\"\"\n    print(f\"I have a &#123;animal_type&#125;.\")\n    print(f\"My &#123;animal_type&#125;'s name is &#123;animal_name&#125;\")\n\n\ndescribe_animal(animal_name='xiaobai', animal_type='dog')\n\n7.2.3 默认值编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。\n如果你发现调用describe_pet()时，描述的大都是小狗，就可将形参animal_type的默认值设置为’dog’。这样，调用describe_pet()来描述小狗时，就可不提供这种信息：\ndef describe_animal(animal_name, animal_type='dog'):\n    \"\"\"显示宠物的信息\"\"\"\n    print(f\"I have a &#123;animal_type&#125;.\")\n    print(f\"My &#123;animal_type&#125;'s name is &#123;animal_name&#125;\")\n\n\ndescribe_animal('xiaobai')\n\n请注意，在这个函数的定义中，修改了形参的排列顺序。由于给animal_type指定了默认值，无需通过实参来指定动物类型，因此在函数调用中只包含一个实参——宠物的名字。然而，Python依然将这个实参视为位置实参，因此如果函数调用中只包含宠物的名字，这个实参将关联到函数定义中的第一个形参。这就是需要将pet_name放在形参列表开头的原因所在。\n7.3 返回值函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值。在函数中，可使用return语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。\n7.3.1 返回简单值def get_formatted_name(first_name, last_name):\n    \"\"\"返回整洁的姓名\"\"\"\n    full_name = first_name + ' ' + last_name\n    return full_name.title()\n\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n7.3.2 让实参变为可选的的有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。\t\n同时提供名、中间名和姓，并非所有的人都有中间名，但如果你调用这个函数时只提供了名和姓，它将不能正确地运行。为让中间名变成可选的，可给实参middle_name指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参。为让get_formatted_name()在没有提供中间名时依然可行，可给实参middle_name指定一个默认值——空字符串，并将其移到形参列表的末尾：\ndef get_formatted_name(first_name, last_name, middle_name=''):\n    \"\"\"返回整洁的姓名\"\"\"\n    if middle_name:\n        full_name = first_name + ' ' + middle_name + ' ' + last_name\n    else:\n        full_name = first_name + ' ' + last_name\n    return full_name.title()\n\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\nmusician = get_formatted_name('john', 'hooker', 'lee')\nprint(musician)\n\n7.3.3 返回一个字典def build_person(first_name, last_name, age=''):\n    \"\"\"返回一个字典，其中包含有关一个人的信息\"\"\"\n    person = &#123;'first': first_name, 'last': last_name&#125;\n    if age:\n        person['age'] = age\n    return person\n\n\nmusician = build_person('jimi', 'hendrix', age='27')\nprint(musician)\n\n函数定义中，我们新增了一个可选形参age，并将其默认值设置为空字符串。如果函数调用中包含这个形参的值，这个值将存储到字典中。在任何情况下，这个函数都会存储人的姓名，但可对其进行修改，使其也存储有关人的其他信息.\n7.4 传递列表def greet_users(names):\n    \"\"\"向列表中的每位用户都发出简单的问候\"\"\"\n    for name in names:\n        msg = \"Hello, \" + name.title() + \"!\"\n        print(msg)\n\n\nusernames = ['hannah', 'ty', 'margot']\ngreet_users(usernames)\n\n7.5 传递任意数量的形参​\t有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。\ndef make_pizza(*toppings):\n    \"\"\"打印顾客点的所有配料\"\"\"\n    print(toppings)\n\n\nmake_pizza('pepperoni')\nmake_pizza('mushrooms', 'green peppers', 'extra cheese')\n\n形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中。函数体内的print语句通过生成输出来证明Python能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。它以类似的方式处理不同的调用，注意，Python将实参封装到一个元组中，即便函数只收到一个值也如此\n7.5.1 结合使用位置实参和任意数量的实参如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。\ndef make_pizza(size, *toppings):\n    \"\"\"概述要制作的比萨\"\"\"\n    print(\"\\nMaking a \" + str(size) +\n          \"-inch pizza with the following toppings:\")\n    for topping in toppings:\n        print(\"- \" + topping)\n\n\nmake_pizza(16, 'pepperoni')\nmake_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\n7.5.2 使用任意数量的关键字实参有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。一个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。在下面的示例中，函数build_profile()接受名和姓，同时还接受任意数量的关键字实参：\ndef build_profile(first, last, **user_info):\n    \"\"\"创建一个字典，其中包含我们知道的有关用户的一切\"\"\"\n    profile = &#123;'first_name': first, 'last_name': last&#125;\n    for key, value in user_info.items():\n        profile[key] = value\n    return profile\n\n\nuser_profile = build_profile('albert', 'einstein',\n                             location='princeton',\n                             field='physics')\nprint(user_profile)\n\n\n\n形参**user_info中的两个星号让Python创建一个名为user_info的空字典，并将收到的所有名称—值对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问user_info中的名称—值对。\n7.6 将函数存储在模块中函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块中的代码。通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。这还能让你在众多不同的程序中重用函数。将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序。知道如何导入函数还能让你使用其他程序员编写的函数库。\n7.6.1 导入整个模块将整个函数单独存为一个文件。\n\npizza.py\n\ndef make_pizza(size, *toppings): \n    \"\"\"概述要制作的比萨\"\"\"\n    print(\"\\nMaking a \" + str(size) +\n          \"-inch pizza with the following toppings:\")\n    for topping in toppings:\n        print(\"- \" + topping)\n\n\nmaking_pizzas.py\n\nimport pizza\npizza.make_pizza(16, 'pepperoni')\npizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')\n\nPython读取这个文件时，代码行import pizza让Python打开文件pizza.py，并将其中的所有函数都复制到这个程序中。你看不到复制的代码，因为这个程序运行时，Python在幕后复制这些代码。你只需知道，在making_pizzas.py中，可以使用pizza.py中定义的所有函数。\n这就是一种导入方法：只需编写一条import语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。如果你使用这种import语句导入了名为module_name.py的整个模块，就可使用下面的语法来使用其中任何一个函数：\nmodule_name.function_name()\n7.6.2 导入特定的函数你还可以导入模块中的特定函数，这种导入方法的语法如下：\nfrom module_name import function_name\nfrom module_name import function_0, function_1, function_2\n7.6.3 使用as给函数、模块指定别名from pizza import make_pizza as mp\nimport numpy as np\n7.6.4 导入模块中所有函数使用星号（*）运算符可让Python导入模块中的所有函数：\nimport语句中的星号让Python将模块pizza中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。这里之所以介绍这种导入方法，只是想让你在阅读别人编写的代码时，如果遇到类似于下面的import语句，能够理解它们：\nfrom module_name import * \n7.7 函数编写指南编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它：他们完全可以相信代码如描述的那样运行；只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。\n7.8 打包程序八、类面向对象编程是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。\n8.1 创建和使用类编写个表示小狗的简单类Dog——它表示的不是特定的小狗，而是任何小狗。大多数狗都有年龄和名字信息，蹲下和打滚两种行为。\n8.1.1 创建Dog类class Dog:\n    \"\"\"一次模拟小狗的简单尝试\"\"\"\n\n    def __init__(self, name, age):\n        \"\"\"\"初始化属性name和age\"\"\"\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        \"\"\"模拟小狗被命令时蹲下\"\"\"\n        print(self.name.title()+\" is now sitting.\")\n\n    def roll_over(self):\n        \"\"\"模拟小狗被命令是打滚\"\"\"\n        print(self.name.title()+\" rolled over!\")\n\nclass用于定义类,而类的名字规定首字母大写。\n\n方法 __init__类中的函数称为方法；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。\n\n__init__()是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。\n我们将方法__init__()定义成了包含三个形参：self、name和age。形参self必不可少，必须位于其他形参的前面。当调用此方法创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。每当我们根据Dog类创建实例时，都只需给最后两个形参（name和age）提供值。\n以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。self.name &#x3D; name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。self.age &#x3D; age的作用与此类似。\nDog类还定义了另外两个方法：sit()和roll_over()（见）。由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self。\n8.1.2 根据类创建实例class Dog:\n    \"\"\"一次模拟小狗的简单尝试\"\"\"\n\n    def __init__(self, name, age):\n        \"\"\"\"初始化属性name和age\"\"\"\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        \"\"\"模拟小狗被命令时蹲下\"\"\"\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        \"\"\"模拟小狗被命令是打滚\"\"\"\n        print(self.name.title() + \" rolled over!\")\n\n\nmy_dog = Dog('willie', 6)\n\nprint(\"My dog's name is \" + my_dog.name.title() + '.')\nprint(\"My dog is \" + str(my_dog.age) + \" years old\")\nmy_dog.sit()\nmy_dog.roll_over()\n\nPython使用实参’willie’和6调用Dog类中的方法__init__()。方法__init__()创建一个表示特定小狗的示例，并使用我们提供的值来设置属性name和age。方法__init__()并未显式地包含return语句，但Python自动返回一个表示这条小狗的实例。我们将这个实例存储在变量my_dog中。在这里，命名约定很有用：我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog）指的是根据类创建的实例。\n\n创建多个实例\n\nclass Dog:\n    \"\"\"一次模拟小狗的简单尝试\"\"\"\n\n    def __init__(self, name, age):\n        \"\"\"\"初始化属性name和age\"\"\"\n        self.name = name\n        self.age = age\n\n    def sit(self):\n        \"\"\"模拟小狗被命令时蹲下\"\"\"\n        print(self.name.title() + \" is now sitting.\")\n\n    def roll_over(self):\n        \"\"\"模拟小狗被命令是打滚\"\"\"\n        print(self.name.title() + \" rolled over!\")\n\n\nmy_dog = Dog('willie', 6)\nyour_dog = Dog('lucy', 3)\n\nprint(\"My dog's name is \" + my_dog.name.title() + '.')\nprint(\"My dog is \" + str(my_dog.age) + \" years old\")\nmy_dog.sit()\nprint(\"Your dog's name is \" + your_dog.name.title() + '.')\nprint(\"Your dog is \" + str(your_dog.age) + \" years old\")\nyour_dog.roll_over()\n\n8.2 使用类和实例8.2.1 Car类class Car:\n    \"\"\"一次模拟汽车的简单尝试\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"初始化描述汽车的属性\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n\n    def get_descriptive_name(self):\n        \"\"\"返回整洁的描述性信息\"\"\"\n        long_name = str(self.year)+' '+self.make+' '+self.model\n        return long_name\n\n\nmy_new_car = Car('Audi', 'A8L', 2020)\nprint(my_new_car.get_descriptive_name())\n\n为让这个类更有趣，下面给它添加一个随时间变化的属性，它存储汽车的总里程。\n8.2.2 给属性指定默认值​\t类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法__init__()内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。\n下面来添加一个名为odometer_reading的属性，其初始值总是为0。我们还添加了一个名为read_odometer()的方法，用于读取汽车的里程表：\nclass Car:\n    \"\"\"一次模拟汽车的简单尝试\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"初始化描述汽车的属性\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"返回整洁的描述性信息\"\"\"\n        long_name = str(self.year)+' '+self.make+' '+self.model\n        return long_name\n\n    def read_odometer(self):\n        \"\"\"打印一条指出汽车里程的信息\"\"\"\n        print(f\"This car has &#123;self.odometer_reading&#125; miles on it.\")\n\n\nmy_new_car = Car('Audi', 'A8L', 2020)\nprint(my_new_car.get_descriptive_name())\nmy_new_car.read_odometer()\n\n8.2.3 修改属性的值\n直接修改属性的值\n\n要修改汽车的里程为23\nmy_new_car.odometer_reading = 23\nmy_new_car.read_odometer() \n\n​\t2.通过方法修改属性的值\ndef update_odometer(self, mileage):\n\t\"\"\"将里程表读数设置为指定的值\"\"\"\n\tself.odometer_reading = mileage\n    \n my_new_car.update_odometer(23)\nmy_new_car.read_odometer()\n\n可对方法update_odometer()进行扩展，使其在修改里程表读数时做些额外的工作。下面来添加一些逻辑，禁止任何人将里程表读数往回调：\ndef update_odometer(self, mileage):\n       \"\"\" 将里程表读数设置为指定的值\n           禁止将里程表读数往回调\n       \"\"\"\n       if mileage >= self.odometer_reading:\n           self.odometer_reading = mileage\n       else:\n           print(\"You can't roll back an odometer!\")\n\n8.3 继承编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。\n8.3.1 子类的方法__init__()创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法__init__()需要父类施以援手。模拟电动汽车。电动汽车是一种特殊的汽车，因此我们可以在前面创建的Car类的基础上创建新类ElectricCar，这样我们就只需为电动汽车特有的属性和行为编写代码。\nclass Car:\n    \"\"\"一次模拟汽车的简单尝试\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"初始化描述汽车的属性\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"返回整洁的描述性信息\"\"\"\n        long_name = str(self.year)+' '+self.make+' '+self.model\n        return long_name\n\n    def read_odometer(self):\n        \"\"\"打印一条指出汽车里程的信息\"\"\"\n        print(f\"This car has &#123;self.odometer_reading&#125; miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\" 将里程表读数设置为指定的值\n            禁止将里程表读数往回调\n        \"\"\"\n        if mileage >= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n\n    def increment_odometer(self, miles):\n        \"\"\"增加里程表的值\"\"\"\n        self.odometer_reading += miles\n\n\nclass ElectricCar(Car):\n    \"\"\"电动汽车的独特之处\"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"初始父类的属性\"\"\"\n        super().__init__(make, model, year)\n\n\nmy_tesla = ElectricCar('tesla', 'model s', 2020)\nprint(my_tesla.get_descriptive_name())\n\nsuper()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法__init__()，让ElectricCar实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。\n8.3.2 给子类定义属性和方法class ElectricCar(Car):\n    \"\"\"电动汽车的独特之处\n       初始化父类的属性，再初始化电动车的属性\n    \"\"\"\n    def __init__(self, make, model, year):\n        \"\"\"初始父类的属性\"\"\"\n        super().__init__(make, model, year)\n        self.battery_size = 70\n\n    def describe_battery(self):\n        \"\"\"打印一条描述电瓶容量的信息\"\"\"\n        print(f\"This car has  a &#123;self.battery_size&#125;-kwh battery.\")\n\n\nmy_tesla = ElectricCar('tesla', 'model s', 2020)\nprint(my_tesla.get_descriptive_name())\nmy_tesla.describe_battery()\n\n8.3.4 重写父类的方法对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。\nclass ElectricCar(Car):\n--snip--\n\tdef fill_gas_tank():\n    \"\"\"电动汽车没有油箱\"\"\"\n    print(\"This car doesn't need a gas tank!\")\n\n使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。\n8.3.4 将实例用作属性使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。\n不断给ElectricCar类添加细节时，我们可能会发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为Battery的类中，并将一个Battery实例用作ElectricCar类的一个属性：\nclass Car(): \n--snip-- \nclass Battery:\n    \"\"\"一次模拟电动车电瓶的尝试\"\"\"\n\n    def __init__(self, battery_size=70):\n        \"\"\"初始化电瓶的属性\"\"\"\n        self.battery_size = battery_size\n\n    def describe_battery(self):\n        \"\"\"打印一条电瓶容量的信息\"\"\"\n        print(f\"This car has a &#123;str(self.battery_size)&#125;-kwh battery.\")\n\n\nclass ElectricCar(Car):\n    \"\"\"电动汽车的独特之处\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"\n        初始化父类的属性，再初始化电瓶车特有的属性\n        \"\"\"\n        super().__init__(make, model, year)\n        self.battery = Battery()\n\n\nmy_tesla = ElectricCar('tesla','model s', '2020')\nprint(my_tesla.get_descriptive_name())\nmy_tesla.battery.describe_battery()\n\n在ElectricCar类中，我们添加了一个名为self.battery的属性。这行代码让Python创建一个新的Battery实例（由于没有指定尺寸，因此为默认值70），并将该实例存储在属性self.battery中。每当方法__init__()被调用时，都将执行该操作；因此现在每个ElectricCar实例都包含一个自动创建的Battery实例。\n8.4 导入类随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块中，然后在主程序中导入所需的模块。\n8.4.1 导入单个类创建单个文件car.py用来储存Car类，然后创建my_car来导入Car类;\ncar.py\n\"\"\"一个可用于表示汽车的类\"\"\"\n\n\nclass Car:\n    \"\"\"一次模拟汽车的简单尝试\"\"\"\n\n    def __init__(self, make, model, year):\n        \"\"\"初始化描述汽车的属性\"\"\"\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    def get_descriptive_name(self):\n        \"\"\"返回整洁的描述性信息\"\"\"\n        long_name = str(self.year)+' '+self.make+' '+self.model\n        return long_name\n\n    def read_odometer(self):\n        \"\"\"打印一条指出汽车里程的信息\"\"\"\n        print(f\"This car has &#123;self.odometer_reading&#125; miles on it.\")\n\n    def update_odometer(self, mileage):\n        \"\"\" 将里程表读数设置为指定的值\n            禁止将里程表读数往回调\n        \"\"\"\n        if mileage >= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n\n    def increment_odometer(self, miles):\n        self.odometer_reading += miles\n\n\n我们包含了一个模块级文档字符串，对该模块的内容做了简要的描述。你应为自己创建的每个模块都编写文档字符串\nmy_car.py\nfrom car import Car\n\nmy_new_car = Car('audi', 'a8', '2022')\nprint(my_new_car.get_descriptive_name())\n\nmy_new_car.odometer_reading = 23\nmy_new_car.read_odometer()\n\n\n导入类是一种有效的编程方式。如果在这个程序中包含了整个Car类，它该有多长呀！通过将这个类移到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易于阅读了。这还能让你将大部分逻辑存储在独立的文件中；确定类像你希望的那样工作后，你就可以不管这些文件，而专注于主程序的高级逻辑了。\n8.4.2 导入多个类可根据需要在程序文件中导入任意数量的类。如果我们要在同一个程序中创建普通汽车和电动汽车，就需要将Car和ElectricCar类都导入：\nfrom car import Car, ElectricCar\n\nmy_beetle = Car('volkswagen', 'beetle', 2016)\nprint(my_beetle.get_descriptive_name())\nmy_tesla = ElectricCar('tesla', 'roadster', 2016)\nprint(my_tesla.get_descriptive_name()) \n\n8.4.3 导入整个模块import car\n8.4.4 导入模块中所有类from module_name import * \n不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的import语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使用这种方式，但你可能会在别人编写的代码中见到它。\n九、文件和异常9.1 文件基本操作f=open(filename)\t#打开文件\nf.write(\"hello world\")\t#写操作\nf.read()\t#读操作(读取所有),鼠标光标停留在最后\nf.readline()\t#读一行，光标停留在改行结尾\nf.close()\t#保存并关闭\nwith open(filename) as file_name:\t#只在使用的时候打开，不用自动关闭\n\n9.1.1 文件打开模式r #只读模式\nw #创建模式，若已存在，则覆盖旧文件\na #追加模式，新数据加写到文件末尾\nw+ \t#写读模式，写一段内容，再将其读取出来\nr+\t#读写模式，能读能写，但都是写在文件最后，跟追加一样\na+\t#追加读，一打开光标就在文件尾部\n\n9.2遍历文件利用循环，遍历文件内容。\nfilename = 'data.txt'\nwith open(filename) as file_object:\n    lines = file_object.readlines()\n\nfor line in lines:\n    print(line.strip())\n\n9.2.1 将遍历内容存入列表f = open(\"data.txt\")\nprint(f.readlines())\n\n9.2.3 二进制操作文件当要打开的文件为图片(视频)时，打开方式的encoding二进制模式（默认为utf-8)\nrb\t#二进制只读\nwb\t#二进制创建模式，若文件已存在则覆盖\nab\t#二进制追加，新数据写到文件末尾\n\n9.3 其他功能f.seek()\t#移动光标，按字节大小分。(中文utf-8三个字节，jbk两个字节)\nf.tell()\t#返回光标当前位置\nf.flush()\t#强制将内存的buffer刷到硬盘\n\n9.4 异常处理​\tPython使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。\n9.4.1 try-expect代码块当你认为可能发生了错误时，可编写一个try-except代码块来处理可能引发的异常。你让Python尝试运行一些代码，并告诉它如果这些代码引发了指定的异常，该怎么办。在数学中0不能放在分母，同样在python中会报错ZeroDivisionError\ntry:\n    print(5/0)\nexcept ZeroDivisionError:\n    print(\"You can't divide by zero!\")\nelse:\n    print(\"right\")\n\n我们将导致错误的代码行print(5&#x2F;0)放在了一个try代码块中。如果try代码块中的代码运行起来没有问题，Python将跳过except代码块；如果try代码块中的代码导致了错误，Python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。\n9.5 存储数据  JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。\nimport json\njson.dump()\t#用来写入\njson.load()\t#用于读取\n\nimport json\n\nfilename = \"username.json\"\ntry:\n    with open(\"username.json\") as f_obj:\n        username = json.load(f_obj)\nexcept FileNotFoundError:\n    username = input(\"whats your name\")\n    with open(\"username.json\",'w') as f_obj:\n        json.dump(username,f_obj)\n        print(f\"we will remember you when you come back &#123;username&#125;!\")\nelse:\n    print(f\"welcome back,&#123;username&#125;\")\n\n","slug":"Python基础","date":"2022-11-09T04:35:20.000Z","categories_index":"Python","tags_index":"python","author_index":"XXXWANG"},{"id":"1c864ee8c45d128c1db0522699c2fec9","title":"数据结构（C)--线性表","content":"线性表\n线性表的定义线性表（List）：零个或多个数据元素的有限序列。\n线性表的数据集合为{a1,a2,…,an}，假设每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。\n\n一、顺序表的顺序存储结构1、顺序表的基本概念概念：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。\n特点：逻辑上相邻的数据元素，物理次序也是相邻的。\n2、顺序表存储结构#include &lt;stdio.h>\n#include &lt;stdlib.h>\n\n#define MaxSize 50\t//线性表存储空间的初始分配量\ntypedef int ElemType;//顺序表中的元素的类型\n//静态分配\ntypedef struct &#123;\n\tElemType data[MaxSize];//定义的数组，用来存元素\n\tint length;//当前顺序表中有多少个元素\n&#125;SqList;\n\n\n3、顺序表的插入\n/*\n插入操作\n初始条件：顺序表L已存在\n操作结果：从1开始，在L中的第i个位置之前插入新的数据元素e，L的长度加1\nbool用来返回插入是否成功的结果\n&amp;为C++语法 为引用变量\n*/\nbool ListInsert(SqList&amp; L, int i, ElemType e)\n&#123;\n\tif (i&lt;1 || i>L.length + 1)//判断要插入的位置是否合法\n\t\treturn false;\n\tif (L.length >= MaxSize)//元素存满了，超出了空间\n\t\treturn false; \n\tfor (int j = L.length; j >= i; j--)//移动顺序表中的元素，依次往后移动\n\t\tL.data[j] = L.data[j - 1];\n\tL.data[i - 1] = e;//数组下标从零开始，插入第一个位置，访问的下标为0\n\tL.length++;\n\treturn true;\n&#125;\n\n4、顺序表的删除/*\n删除操作\n初始条件：顺序表L已存在\n操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1\n删除使用元素e的引用的目的是拿出对应的值\n*/\nbool ListDelete(SqList&amp; L,int i,ElemType&amp; e)\n&#123;\n\tif (i&lt;1 || i>=L.length + 1)//判断删除的位置是否合法\n\t\treturn false;\n\tif (L.length == 0)\n\t&#123;\n\t\treturn false;\n\t&#125;\n\te = L.data[i - 1];//获取顺序表中对应的元素，赋值给e\n\tfor (int j = i; j &lt; L.length; j++)\n\t\tL.data[j - 1] = L.data[j];\n\tL.length--;//删除一个元素，顺序表长度减1\n\treturn true;\n&#125;\n\n5、查找元素在顺序表中的位置//查找成功，返回位置，位置从1开始，查找失败，返回0\nint LocateElem(SqList L, ElemType e)\n&#123;\n\tint i;\n\tfor (i = 0; i &lt; L.length; i++)\n\t\tif (L.data[i] == e)\n\t\t\treturn i + 1;//加1就是元素在顺序表中的位置\n\treturn 0;\n&#125;\n\n6、读取顺序表所有元素void PrintList(SqList L)\n&#123;\n\tfor (int i = 0; i &lt; L.length; i++)\n\t&#123;\n\t\tprintf(\"%3d\", L.data[i]);\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n7、运行测试int main()\n&#123;\n\tSqList L;//顺序表的名称\n\tbool ret;//查看返回值，布尔型C++\n\tElemType del;//用来存要删除的元素\n\t//首先手动在顺序表中赋值\n\tL.data[0] = 1;\n\tL.data[1] = 2;\n\tL.data[2] = 3;\n\tL.length = 3;//总共三个元素\n\tret = ListInsert(L, 2, 60);//第二个位置插入60\n\tif (ret)\n\t&#123;\n\t\tprintf(\"插入成功\\n\");\n\t\tPrintList(L);//打印顺序表\n\t&#125;\n\telse &#123;\n\t\tprintf(\"插入失败\\n\");\n\t&#125;\n\tret = ListDelete(L, 1, del);//删除第一个位置的元素，并把元素输出\n\tif (ret)\n\t&#123;\n\t\tprintf(\"删除成功\\n\");\n\t\tprintf(\"删除元素值为%d\\n\",del);\n\t\tPrintList(L);\n\t&#125;\n\telse &#123;\n\t\tprintf(\"删除失败\\n\");\n\t&#125;\n\tret = LocateElem(L, 60);\n\tif (ret)\n\t&#123;\n\t\tprintf(\"查找成功\\n\");\n\t\tprintf(\"元素位置为%d\\n\", ret);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(\"查找失败\\n\");\n\t&#125;\n\n\treturn 0;\n&#125;\n\n运行结果：\n\n二、顺序表的链式存储结构2.1 单链表1、单链表的基本概念在链式结构中，除了要存储数据元素的信息外，还要存储它的后继元素的存储地址。因此，为了表示每个数据元素ai与其直接后继元素ai+1之间的逻辑关系，对数据ai来说，除了存储其本身的信息之外，还需要存储一个指示其直接后继的信息（即直接后继的存储位置）。我们吧把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。n个结点（ai的存储映像）链结成一个链表，即为线性表（a1, a2, …, an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。\n\n通常用头指针来标识一个单链表，如单链表厶头指针为NULL时表示一个空表。此外， 为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。\n\n头结点和头指针的区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息。 \n2、单链表的储存结构typedef struct LNode&#123;\t\t//定义单链表结点类型\n\tElemType data;\t\t\t//数据域\n\tstruct LNode *next;\t\t//指针域\n&#125;LNode, *LinkList;\n\n3、采用头插法建立单链表\nLinkList CreatList1(LinkList&amp; L)//list_head_insert\n&#123;\n\tLNode* s; int x;\n\tL = (LinkList)malloc(sizeof(LNode));//带头结点的链表\n\tL->next = NULL;//L->data里面没放东西\n\tscanf(\"%d\",&amp;x);//从标准输入中读取数据\n\t//3 4 5 6 7 9999\n\twhile (x != 9999) &#123;\n\t\ts = (LNode*)malloc(sizeof(LNode));//申请一个新空间给s，强制类型转换\n\t\ts->data = x;//把读取到的值，给新空间的data成员\n\t\ts->next = L->next;//让新节点的next指针指向链表的第一个元素(第一个放数据的元素）\n\t\tL->next = s;//让s作为第一个元素\n\t\tscanf(\"%d\", &amp;x);//读取标准输入\n\t&#125;\n\treturn L;\n&#125; \n\n4、采用尾插法建立单链表头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r,使其始终指向当前链表的尾结点。\n\nLinkList CreatList2(LinkList&amp; L)//list_tail_insert\n&#123;\n\tint x;\n\tL = (LinkList)malloc(sizeof(LNode));//带头节点的链表\n\tLNode* s, * r = L;//LinkList s,r=L也可以,r代表链表表尾节点，指向链表尾部\n\t//3 4 5 6 7 9999\n\tscanf(\"%d\", &amp;x);\n\twhile (x != 9999) &#123;\n\t\ts = (LNode*)malloc(sizeof(LNode));\n\t\ts->data = x;\n\t\tr->next = s;//让尾部节点指向新节点\n\t\tr = s;//r指向新的表尾节点\n\t\tscanf(\"%d\", &amp;x);\n\t&#125;\n\tr->next = NULL;//尾节点的next指针赋值为NULL\n\treturn L;\n&#125;\n\n5、查找对应节点的位置的值在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域null。\nLinkList GetElem(LinkList L, int i)\n&#123;\n\tint j = 1;\n\tLinkList p = L->next;//让p指向头节点的下一个（第一个节点）\n\tif (0 == i)\n\t&#123;\n\t\treturn L;//i是0就返回头节点\n\t&#125;\n\tif (i &lt; 1)//\n\t&#123;\n\t\treturn NULL;//i是负值就返回NULL\n\t&#125;\n\twhile (p &amp;&amp; j &lt; i)//p不为空andj&lt;i\n\t&#123;\n\t\tp = p->next;\n\t\tj++;\n\t&#125;\n\treturn p;\n&#125;\n\n6、按值查找表结点从单链表的第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e,则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。\nLinkList LocateElem(LinkList L, ElemType e)\n&#123;\n\tLinkList p = L->next;\n\twhile (p != NULL &amp;&amp; p->data != e)\n\t&#123;\n\t\tp = p->next;\n\t&#125;\n\treturn p;\n&#125;\n\n7、插入结点操作插入结点操作将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。算法首先调用按序号查找算法GetElem(L,i-l),查找第i-l个结点。假设返回的第i-1个结点为P，然后令新结点s的指针域指向p的后继结点，再令结点P的指针域指向新插入的结点*S。\n\nbool ListFrontInsert(LinkList L, int i, ElemType e)\n&#123;\n\tLinkList p = GetElem(L,i - 1);//拿到要插入位置的前一个位置的地址值\n\tif (NULL == p)\n\t&#123;\n\t\treturn false;//i不对\n\t&#125;\n\tLinkList s = (LinkList)malloc(sizeof(LNode));\n\ts->data = e;\n\ts->next = p->next;\n\tp->next = s;\n\treturn true;\n&#125;\n\n8、删除节点操作删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除\n\n假设结点* P为找到的被删结点的前驱结点，为实现这一操作后的逻辑关系的变化，仅需修改* P的指针域，即将* p的指针域next指向*q的下一结点。\nbool ListDelete(LinkList L, int i)\n&#123;\n\tLinkList p = GetElem(L, i - 1);////拿到要删除位置的前一个位置的地址值\n\tif (NULL == p)\n\t&#123;\n\t\treturn false;//要删除的位置不存在\n\t&#125;\n\tLinkList q = p->next;\n\tif (NULL == q)\n\t&#123;\n\t\treturn false;//要删除的位置不存在\n\t&#125;\n\tp->next = q->next;//断链\n\tfree(q);//释放对应节点的空间\n\tq = NULL;//为了避免野指针\n\treturn true;\n&#125;\n\n9、打印链表void PrintList(LinkList L)\n&#123;\n\tL = L->next;\n\twhile (L != NULL)\n\t&#123;\n\t\tprintf(\"%3d\",L->data);//打印当前节点顺序\n\t\tL = L->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n\n10、运行测试int main()\n&#123;\n\tLinkList L;//链表头,是结构体指针类型\n\tLinkList search;//用来存储拿到的某一个节点\n\t//CreatList1(L);//输入数据可以为3 4 5 6 7 9999\n\t//PrintList(L);\n\tCreatList2(L);\n\tPrintList(L);\n\tsearch = GetElem(L, 2);//查找链表第二个位置的元素值\n\tif (search != NULL)\n\t&#123;\n\t\tprintf(\"\\n按序号查找成功\\n\");\n\t\tprintf(\"%d\\n\", search->data);\n\t&#125;\n\tsearch = LocateElem(L, 6);//按值查询\n\tif (search != NULL)\n\t&#123;\n\t\tprintf(\"按值查询成功\\n\");\n\t\tprintf(\"%d\\n\", search->data);\n\t&#125;\n\tListFrontInsert(L,2,99);//新节点插入第i个位置\n\tPrintList(L);\n\tListDelete(L, 4);//删除第第四个节点\n\tPrintList(L);\n\treturn 0;\n&#125;\n\n\n2.2 双向链表1、双向链表的基本概念单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。要访问某个结点的前驱结点（插入、删除操作时），只能从头开始遍历，访问后继结点的时间复杂度为O（1）,访问前驱结点的时间复杂度为O（n）。\n为了克服单链表的上述缺点，引入了双链表，双链表结点中有两个指针prior和next,分别指向其前驱结点和后继结点.\n\n2、双向链表的存储结构typedef int ElemType;\ntypedef struct DNode &#123;\n\tElemType data;\n\tstruct DNode* prior, * next;//前驱，后继\n&#125;DNode,*DLinkList;\n\n3、双向链表头插法DLinkList Dlist_head_insert(DLinkList&amp; DL)\n&#123;\n\tDNode* s; int x;\n\tDL &#x3D; (DLinkList)malloc(sizeof(DNode));&#x2F;&#x2F;带头节点的链表\n\tDL-&gt;next &#x3D; NULL;&#x2F;&#x2F;前驱指针和后继指针都填写NULL\n\tDL-&gt;prior &#x3D; NULL;\n\tscanf(&quot;%d&quot;, &amp;x);&#x2F;&#x2F;从标准输入读取数据\n\t&#x2F;&#x2F;3 4 5 6 7 9999\n\twhile (x !&#x3D; 9999) &#123;\n\t\ts &#x3D; (DLinkList)malloc(sizeof(DNode));&#x2F;&#x2F;申请应该空间，强制转换类型\n\t\ts-&gt;data &#x3D; x;\n\t\ts-&gt;next &#x3D; DL-&gt;next;\n\t\tif (DL-&gt;next !&#x3D; NULL)\n\t\t&#123;\n\t\t\tDL-&gt;next-&gt;prior &#x3D; s;\n\t\t&#125;\n\t\ts-&gt;prior &#x3D; DL;&#x2F;&#x2F;要插入的节点指向头节点\n\t\tDL-&gt;next &#x3D; s;\n\t\tscanf(&quot;%d&quot;, &amp;x);\n\t&#125;\n\treturn DL;\n&#125;\n\n4、双向链表尾插法DLinkList Dlist_tail_insert(DLinkList&amp; DL)\n&#123;\n\tint x;\n\tDL = (DLinkList)malloc(sizeof(DNode));//带头节点的链表\n\tDNode* s, * r = DL;//r代表尾指针\n\tDL->prior = NULL;\n\tscanf(\"%d\", &amp;x);\n\twhile (x != 9999)\n\t&#123;\n\t\ts = (DNode*)malloc(sizeof(DNode));\n\t\ts->data = x;\n\t\tr->next = s;\n\t\ts->prior = r;\n\t\tr = s;//r指向新的表位节点\n\t\tscanf(\"%d\", &amp;x);\n\t&#125;\n\tr->next = NULL;//尾指针的next指针赋值为NULL\n\treturn DL;\n&#125;\n\n5、按序号查找节点值DNode* GetElem(DLinkList DL, int i)\n&#123;\n\tint j = 1;\n\tDNode* p = DL->next;\n\tif (i == 0)\n\t\treturn DL;\n\tif (i &lt; 1)\n\t\treturn NULL;\n\twhile (p &amp;&amp; j &lt; i)\n\t&#123;\n\t\tp = p->next;\n\t\tj++;\n\t&#125;\n\treturn p;\n&#125;\n\n6、插入节点操作在双链表中P所指的结点之后插入结点*s,其指针的变化过程如图所示。\n\nbool DListFrontInsert(DLinkList DL, int i, ElemType e)\n&#123;\n\tDLinkList p = GetElem(DL, i - 1);//找前一个位置的地址\n\tif (NULL == p)\n\t&#123;\n\t\treturn false;\n\t&#125;\n\tDLinkList s = (DLinkList)malloc(sizeof(DNode));//为新插入的节点申请空间\n\ts->data = e;\n\ts->next = p->next;\n\tp->next->prior = s;\n\ts->prior = p;\n\tp->next = s;\n\treturn true;\n&#125;\n\n7 、删除节点操作删除双链表中结点* P的后继结点* q，其指针的变化过程如图所示。\n\nbool DListDelete(DLinkList DL, int i)\n&#123;\n\tDLinkList p = GetElem(DL, i - 1);\n\tif (NULL == p)\n\t&#123;\n\t\treturn false;\n\t&#125;\n\tDLinkList q;\n\tq = p->next;\n\tif (q == NULL)//删除的元素不存在\n\t\treturn false;\n\tp->next = q->next;//断链\n\tif (q->next != NULL)\n\t&#123;\n\t\tq->next->prior = p;\n\t&#125;\n\tfree(q);//释放对应节点的空间\n\treturn true;\n&#125;\n\n8、打印链表void PrintList(DLinkList DL)\n&#123;\n\tDL = DL->next;\n\twhile (DL != NULL)\n\t&#123;\n\t\tprintf(\"%3d\", DL->data);\n\t\tDL = DL->next;\n\t&#125;\n\tprintf(\"\\n\");\n&#125;\n\n9、运行测试int main()\n&#123;\n\tDLinkList DL;\n\tDLinkList search;\n\t//Dlist_head_insert(DL);//头插\n\t//3 4 5 6 7 9999\n\t//PrintList(DL);\n\tDlist_tail_insert(DL);//尾插\n\tPrintList(DL);\n\tsearch = GetElem(DL, 2);\n\tif (search != NULL)\n\t&#123;\n\t\tprintf(\"按序号查找成功\\n\");\n\t\tprintf(\"%d\\n\", search->data);\n\t&#125;\n\tDListFrontInsert(DL, 3, 99);\n\tPrintList(DL);\n\tDListDelete(DL, 2);\n\tPrintList(DL);\n&#125;\n\n\n2.3 循环链表2.3.1 循环单链表循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL,而改为指向头结点,从而整个链表形成一个环，如图所示。\n在循环单链表中，表尾结点* r的next域指向L,故表中没有指针域为NULL的结点，因此,循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。\n\n循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，因此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任意一个结点开始遍历整个链表。有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针，从而使得操作效率更高。其原因是，若设的是头指针，对表尾进行操作需要O(n)的时间复杂度，而若设的是尾指针r, r-&gt;next即为头指针，对表头与表尾进行操作都只需要O(1)的时间复杂度。\n2.3.2 循环双链表由循环单链表的定义不难推岀循环双链表。不同的是在循环双链表中，头结点的prior指针还要指向表尾结点，如图所示。\n\n在循环双链表L中，某结点* p为尾结点时，p-&gt;next&#x3D;&#x3D;L；当循环双链表为空表时，其头结点的prior域和next域都等于L。\n2.4 静态链表静态链表借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next,与前面所讲的链表中的指针不同的是，这里的指针是结点的相对地址(数组下标)，又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。静态链表和单链表的对应关系如图所示。\n\n静态链表的结构#define MaxSize 50\t&#x2F;&#x2F;链表的最大长度\ntypedef struct&#123;\n\tElemType data;\t&#x2F;&#x2F;存储数据元素\n\tint next;\t&#x2F;&#x2F;下一个元素的数组下标\n&#125;SLinkList[MaxSize];\n\n静态链表以next&#x3D;&#x3D;-l作为其结束的标志。静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素。总体来说，静态链表没有单链表使用起来方便，但在一些不支持指针的高级语言(如Basic)中，这是一种非常巧妙的设计方法。\n","slug":"数据结构（C)----线性表的顺序表示","date":"2022-11-09T03:55:20.000Z","categories_index":"C/C++","tags_index":"数据结构","author_index":"XXXWANG"}]